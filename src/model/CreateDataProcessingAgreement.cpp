/**
 * My Data My Consent - Developer API
 * Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@mydatamyconsent.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.0.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "MyDataMyConsent/model/CreateDataProcessingAgreement.h"

namespace mydatamyconsent {
namespace models {



CreateDataProcessingAgreement::CreateDataProcessingAgreement()
{
    m_Version = utility::conversions::to_string_t("");
    m_VersionIsSet = false;
    m_Body = utility::conversions::to_string_t("");
    m_BodyIsSet = false;
    m_AttachmentUrl = utility::conversions::to_string_t("");
    m_AttachmentUrlIsSet = false;
}

CreateDataProcessingAgreement::~CreateDataProcessingAgreement()
{
}

void CreateDataProcessingAgreement::validate()
{
    // TODO: implement validation
}

web::json::value CreateDataProcessingAgreement::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_VersionIsSet)
    {
        val[utility::conversions::to_string_t(U("version"))] = ModelBase::toJson(m_Version);
    }
    if(m_BodyIsSet)
    {
        val[utility::conversions::to_string_t(U("body"))] = ModelBase::toJson(m_Body);
    }
    if(m_AttachmentUrlIsSet)
    {
        val[utility::conversions::to_string_t(U("attachmentUrl"))] = ModelBase::toJson(m_AttachmentUrl);
    }

    return val;
}

bool CreateDataProcessingAgreement::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("version"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("version")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setVersion;
            ok &= ModelBase::fromJson(fieldValue, refVal_setVersion);
            setVersion(refVal_setVersion);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("body"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("body")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setBody;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBody);
            setBody(refVal_setBody);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("attachmentUrl"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("attachmentUrl")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAttachmentUrl;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAttachmentUrl);
            setAttachmentUrl(refVal_setAttachmentUrl);
        }
    }
    return ok;
}

void CreateDataProcessingAgreement::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_VersionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("version")), m_Version));
    }
    if(m_BodyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("body")), m_Body));
    }
    if(m_AttachmentUrlIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("attachmentUrl")), m_AttachmentUrl));
    }
}

bool CreateDataProcessingAgreement::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("version"))))
    {
        utility::string_t refVal_setVersion;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("version"))), refVal_setVersion );
        setVersion(refVal_setVersion);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("body"))))
    {
        utility::string_t refVal_setBody;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("body"))), refVal_setBody );
        setBody(refVal_setBody);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("attachmentUrl"))))
    {
        utility::string_t refVal_setAttachmentUrl;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("attachmentUrl"))), refVal_setAttachmentUrl );
        setAttachmentUrl(refVal_setAttachmentUrl);
    }
    return ok;
}

utility::string_t CreateDataProcessingAgreement::getVersion() const
{
    return m_Version;
}

void CreateDataProcessingAgreement::setVersion(const utility::string_t& value)
{
    m_Version = value;
    m_VersionIsSet = true;
}

bool CreateDataProcessingAgreement::versionIsSet() const
{
    return m_VersionIsSet;
}

void CreateDataProcessingAgreement::unsetVersion()
{
    m_VersionIsSet = false;
}
utility::string_t CreateDataProcessingAgreement::getBody() const
{
    return m_Body;
}

void CreateDataProcessingAgreement::setBody(const utility::string_t& value)
{
    m_Body = value;
    m_BodyIsSet = true;
}

bool CreateDataProcessingAgreement::bodyIsSet() const
{
    return m_BodyIsSet;
}

void CreateDataProcessingAgreement::unsetBody()
{
    m_BodyIsSet = false;
}
utility::string_t CreateDataProcessingAgreement::getAttachmentUrl() const
{
    return m_AttachmentUrl;
}

void CreateDataProcessingAgreement::setAttachmentUrl(const utility::string_t& value)
{
    m_AttachmentUrl = value;
    m_AttachmentUrlIsSet = true;
}

bool CreateDataProcessingAgreement::attachmentUrlIsSet() const
{
    return m_AttachmentUrlIsSet;
}

void CreateDataProcessingAgreement::unsetAttachmentUrl()
{
    m_AttachmentUrlIsSet = false;
}
}
}


